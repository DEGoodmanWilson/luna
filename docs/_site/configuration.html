<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Luna</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index.html"><img src="img/luna.png" alt="luna" /></a>
        <p class="view"><a href="https://github.com/DEGoodmanWilson/luna">View the Project on GitHub <small>DEGoodmanWilson/luna</small></a></p>
        <h1>An embedded HTTP server in C++14</h1>

        <h2>Getting Started</h2>
        <ul>
          <li><a href="using.html">Using in your project</a></li>
        </ul>
        <h2>Using Luna</h2>
        <ul>
          <li><a href="configuration.html">Configuration options</a></li>
          <li><a href="simple_api_endpoint.html">Simple API endpoints</a></li>
          <li><a href="regexes.html">Endpoints using regexes</a></li>
          <li>HTTPS</li>
        </ul>
        <h2>Changelog</h2>
        <ul>
          
          
          <!-- This is a silly hack to get the Changelog page URL, but populate the sidebar with changelog entries that links into the main changelog page -->
          
            
            <li><a href="/changelog#2.8.0" >2.8.0</a></li>
          
            
            <li><a href="/changelog#2.7.1" >2.7.1</a></li>
          
            
            <li><a href="/changelog#2.7.0" >2.7.0</a></li>
          
            
            <li><a href="/changelog#2.0.0" >2.0.0</a></li>
          
            
            <li><a href="/changelog#1.0.0" >1.0.0</a></li>
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
        </ul>
      </header>
      <section>
      <p>Luna has a lot of options. Most of them are based on the options to the underlying <code class="highlighter-rouge">libmicrohttpd</code> library that Luna wraps.
Options are pretty straightforward to set when creating a server. Read on to learn how to set options, and to learn more
about the options available to be set.</p>

<h1 id="global-configuration-options">Global configuration options</h1>

<h2 id="logger">Logger</h2>

<p>The Luna logger is a <code class="highlighter-rouge">functional</code> type that you provide. To set it, you can pass to <code class="highlighter-rouge">luna::set_logger()</code> a function pointer, a non-static class method via <code class="highlighter-rouge">std::bind</code>, an <code class="highlighter-rouge">std::function</code> object, or a lambda with the following signature</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void (luna::log_level, const std::string &amp;)
</code></pre>
</div>

<p>For example, to log messages to <code class="highlighter-rouge">stdout</code>, we could write a lambda:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>luna::set_logger([](luna::log_level level, const std::string &amp;message)
{
    std::cout &lt;&lt; to_string(level) &lt; ": " &lt;&lt; message &lt;&lt; std::endl;
});
</code></pre>
</div>

<h1 id="server-configuration-options">Server configuration options</h1>

<p>As <code class="highlighter-rouge">luna::server</code> is the object through which all interactions happen, configuration options are set via the <code class="highlighter-rouge">server</code> contructor. The most important option may well be the port that your <code class="highlighter-rouge">server</code> object will listen on:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>using namespace luna;
server server_1{server::port{8446}};
auto server_2 = std::make_unique&lt;server&gt;({server::port{8447}});
</code></pre>
</div>

<h2 id="named-configuration-options-and-ordering">Named configuration options and ordering</h2>

<p>All options are passed to the <code class="highlighter-rouge">server</code> constructor using the <em>named option</em> pattern: Each option is set using the option name, and the order that options are passed does not matter. Any options not explicitly set are given sensible defaults.</p>

<p>As an example of the <em>named option</em> pattern, let’s configure a server on port 7000 and a default MIME type of <code class="highlighter-rouge">"text/json"</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>server my_server{server::mime_type{"text/json"}, server::port{8446}};
</code></pre>
</div>

<p>Because with the <em>named option</em> pattern order doesn’t matter, we could have just as easily said</p>

<div class="highlighter-rouge"><pre class="highlight"><code>server my_server{server::port{8446}, server::mime_type{"text/json"}};
</code></pre>
</div>

<h2 id="options-that-are-callbacks">Options that are callbacks</h2>

<p>Some options are for configuring callbacks that you provide. These are easy to set up with C++ lambdas, <code class="highlighter-rouge">std::bind</code>, or
even plain old function pointers.</p>

<p>For example, <code class="highlighter-rouge">error_handler_cb</code> is an option for rendering custom error pages on, <em>e.g.</em> <code class="highlighter-rouge">404</code> errors.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">my_error_handler</span><span class="p">(</span><span class="n">response</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">,</span> <span class="n">request_method</span> <span class="n">method</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//we'll render some simple HTML
</span>    <span class="n">response</span><span class="p">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="s">"text/html; charset=UTF-8"</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status_code</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">404</span><span class="p">:</span>
        <span class="n">response</span><span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="s">"&lt;h1&gt;OH NOES THERE IS NOTHING HERE&lt;/h1&gt;"</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">response</span><span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="s">"&lt;h1&gt;Yikes!&lt;/h1&gt;"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">server</span> <span class="n">my_server</span><span class="p">{</span><span class="n">server</span><span class="o">::</span><span class="n">handler</span><span class="p">{</span><span class="o">&amp;</span><span class="n">my_error_handler</span><span class="p">}};</span>

</code></pre>
</div>

<h1 id="configuration-options-reference">Configuration options reference</h1>

<h2 id="common-options">Common options</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">port</code>: The port to run the HTTPD server on.</p>

    <p>Default: <code class="highlighter-rouge">8080</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">mime_type</code>: The default MIME type to serve up.</p>

    <p>Default: <code class="highlighter-rouge">"text/html"</code></p>
  </li>
</ul>

<h2 id="https--tls-options">HTTPS / TLS options</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">https_mem_key</code>: A string containing the private key to use for TLS. Must be used in conjunction with <code class="highlighter-rouge">https_mem_cert</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">https_mem_cert</code>: A string containing the certificate to use for TLS. Must be used in conjunction with <code class="highlighter-rouge">https_mem_key</code></p>
  </li>
</ul>

<!-- //`https_cred_type`: //TODO probably don't need to define this one. -->

<!-- - `https_priorities`:

- `https_mem_trust`:

- `https_mem_dhparams`:

- `https_key_password`: -->

<h2 id="threading-options">Threading options</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">use_thread_per_connection</code>: Use an independent thread for each connection. Incompatible with <code class="highlighter-rouge">use_epoll_if_available</code> for reasons.</p>

    <p>Default: <code class="highlighter-rouge">false</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">thread_pool_size</code>: Things and stuff</p>

    <p>Default: 1</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">thread_stack_size</code>: Things and stuff</p>

    <p>Default: system default</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">use_epoll_if_available</code>: Use <code class="highlighter-rouge">epoll</code>. Only available on Linux.</p>

    <p>Default: <code class="highlighter-rouge">false</code></p>
  </li>
</ul>

<h2 id="callback-options">Callback options</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">accept_policy_cb</code>: You can choose to accept or reject connections on the basis of their address. The default is to accept all incoming connections regardless of origin.</p>

    <p>Signature: <code class="highlighter-rouge">bool cb(const struct sockaddr *, socklen_t)</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">error_handler_cb</code>: Render a custom error page.</p>

    <p>Signature: <code class="highlighter-rouge">void cb(response &amp;response, request_method method, const std::string &amp;path)</code></p>
  </li>
</ul>

<!-- - `logger_cb`: Oh, so you'd like to get some logs?

    Signature: `void cb(const std::string& message)` -->

<ul>
  <li>
    <p><code class="highlighter-rouge">unescaper_cb</code>: You don’t like the default URL unescaping algorithm? Offer up your own!</p>

    <p>Signature: <code class="highlighter-rouge">std::string cb(const std::string&amp; text)</code></p>
  </li>
</ul>

<h2 id="options-undocumented-at-the-moment-because-i-havent-gotten-around-to-it-yet">Options undocumented at the moment because I haven’t gotten around to it yet</h2>

<!-- //TODO just not going to try to support these two for now
//TODO MHD_OPTION_HTTPS_CERT_CALLBACK cbshim_
//    using notify_connection_cb = std::function<void(struct MHD_Connection *connection, void **socket_context, enum MHD_ConnectionNotificationCode toe)>; -->

<ul>
  <li>
    <p><code class="highlighter-rouge">connection_memory_limit</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">connection_limit</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">connection_timeout</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">per_ip_connection_limit</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">sockaddr_ptr</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">listen_socket</code>:</p>
  </li>
</ul>

<!-- //`digest_auth_random`: //TODO unsure how best to support this one -->

<ul>
  <li>
    <p><code class="highlighter-rouge">nonce_nc_size</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">connection_memory_increment</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">tcp_fastopen_queue_size</code>:</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">listening_address_reuse</code>:</p>
  </li>
</ul>


      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/DEGoodmanWilson">DEGoodmanWilson</a></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>

  </body>
  </html>
