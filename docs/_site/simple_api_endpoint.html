<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Luna</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index.html"><img src="img/luna.png" alt="luna" /></a>
        <p class="view"><a href="https://github.com/DEGoodmanWilson/luna">View the Project on GitHub <small>DEGoodmanWilson/luna</small></a></p>
        <h1>An embedded HTTP server in C++14</h1>

        <h2>Getting Started</h2>
        <ul>
          <li><a href="using.html">Using in your project</a></li>
        </ul>
        <h2>Using Luna</h2>
        <ul>
          <li><a href="configuration.html">Configuration options</a></li>
          <li><a href="simple_api_endpoint.html">Simple API endpoints</a></li>
          <li><a href="regexes.html">Endpoints using regexes</a></li>
          <li>HTTPS</li>
        </ul>
        <h2>Changelog</h2>
        <ul>
          <li><a href="1.0.0.html">1.0.x</a></li>
          <li><a href="1.0.0-beta.html">1.0.0-beta</a></li>
        </ul>
      </header>
      <section>
      <h1 id="defining-a-simple-api-endpoint">Defining a simple API endpoint</h1>

<h2 id="serving-static-html-to-a-simple-endpoint">Serving static HTML to a simple endpoint</h2>

<p>(The code discussed here is available in <code class="highlighter-rouge">examples/example1.cpp</code>.)</p>

<p>Suppose we want to handle a request to <code class="highlighter-rouge">/hello_world</code> by responding with a simple HTML snippet:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;h1&gt;Hello, World!&lt;/h1&gt;
</code></pre>
</div>

<p>Let’s begin by writing a simple function to act as a request handler (nevermind what the request <em>is</em>).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>using namespace luna;
response hello_world(const endpoint_matches &amp;matches, 
                     const query_params     &amp;params)
{
    return {"&lt;h1&gt;Hello, World!&lt;/h1&gt;"};
}
</code></pre>
</div>

<p>Don’t worry about the parameters to the function for now, since we are returning the HTML snippet unconditionally. The important bit is the return statement, which constructs a new <code class="highlighter-rouge">luna::response</code> object. This object actually has three components to it: An HTTP status code, a MIME type, and a string that contains the response body itself. The status code defaults to the appropriate success code for the HTTP method (201 for POST, 200 for everything else). The MIME type defaults to <code class="highlighter-rouge">"text/html"</code>. So we need only provide the HTML itself.</p>

<p>Now, let’s create a <code class="highlighter-rouge">luna::server</code> to host this request handler, and attach the request handler to the server. We want our server to run on port 8443, and our request handler to trigger on a GET to <code class="highlighter-rouge">/hello_world</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main(void)
{
    server server{server::port{8443}};

    server.handle_request(request_method::GET,
                          "/hello_world",
                          &amp;hello_world);

    while (server);
}
</code></pre>
</div>

<p>The first line simply instantiates an HTTP server object on port 8443. The final line just loops forever. It is the second line that is of interest. This line instructs our server to listen for GET requests on <code class="highlighter-rouge">/hello_world</code>, and to call our request handler when it hears such a request.</p>

<h2 id="using-query-parameters">Using query parameters</h2>

<p>(The code discussed here is available in <code class="highlighter-rouge">examples/example2.cpp</code>.)</p>

<p>Of course, we could have loaded this HTML from a file, rather than specifying it with a string constant. Or we can generate it dynamically based on the HTTP query parameters. Indeed, let’s modify our example to echo back the query parameters received.</p>

<p><code class="highlighter-rouge">luna::query_params</code> is simply an alias for a key-value hash stored as an <code class="highlighter-rouge">std::map</code>. The keys and the values both are just <code class="highlighter-rouge">std:strings</code>. So, we might rewrite our request handler as such:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>response hello_world(const endpoint_matches &amp;matches,
                     const query_params     &amp;params)
{
    std::stringstream body;
    body &lt;&lt; "&lt;h1&gt;Hello, World!&lt;/h1&gt;\n&lt;ul&gt;\n";

    for(auto&amp; kv : params)
    {
        body &lt;&lt; "&lt;li&gt;&lt;b&gt;" &lt;&lt; kv.first &lt;&lt; "&lt;/b&gt; " &lt;&lt; kv.second &lt;&lt; "&lt;/li&gt;\n";
    }

    body &lt;&lt; "&lt;/ul&gt;";
    return {body.str()};
}
</code></pre>
</div>

<h2 id="setting-the-status-code">Setting the status code</h2>

<p>The response object contains the status code representing the success or failure of a request. By default, the status code is set to either 201 (for POST requests) or 200 (for all other requests). This is easily overriden to indicate other kinds of success, or a failure.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>return {404, "&lt;h1&gt;Not Found&lt;/h1&gt;"}
</code></pre>
</div>

<h2 id="setting-the-response-mime-type">Setting the response MIME type</h2>

<p>Not all HTTP servers respond with HTML. Many respond with, for example JSON or XML. You can specify a default MIME type for all responses when constructing a new server:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>server server{server::port{8334}, server::mime_type{"text/json"}};
</code></pre>
</div>

<p>Or you can specify MIME types per response in the response contructor:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>return {"text/json", "{\"error\":\"not found\""}};
</code></pre>
</div>

<h2 id="setting-response-headers">Setting response headers</h2>

<p>At this moment, there is no facility for specifying custom response headers.</p>

<h1 id="todo">TODO</h1>
<ul>
  <li>endpoint handlers probably also want the request body, not currently being passed in</li>
  <li>no way to construct a response object with binary data, that’s a real shame</li>
  <li>responses are constructed in memory. Maybe we don’t want that. Maybe we want to provide a hook in a response object for reading data chunks at a time.</li>
  <li>custom response headers</li>
</ul>

      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/DEGoodmanWilson">DEGoodmanWilson</a></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>

  </body>
  </html>
